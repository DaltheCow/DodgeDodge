{"version":3,"sources":["webpack:///webpack/bootstrap 20fe44511922dc709d8b","webpack:///./cubeStore.js","webpack:///./DodgeDodge.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,8BAA8B;AACzC,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,yCAAyC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,+BAA+B;AACxC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,SAAS,+BAA+B;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;ACnEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yFAAyF;AACzF,yFAAyF;AACzF;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA,4CAA4C,gCAAgC;AAC5E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,gBAAgB;;AAElE;;AAEA;AACA,oDAAoD,wCAAwC;AAC5F;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;;;AAGA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB;;AAEpB;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,4EAA4E,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE;AAC5F;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA,2FAA2F;AAC3F,2FAA2F;AAC3F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;AACA,CAAC","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 20fe44511922dc709d8b","class CubeStore {\n  constructor(scene, geometry, material, initialSize) {\n    this.scene = scene;\n    this.geometry = geometry;\n    this.material = material;\n    this.storage = [];\n    this.cubesInScene = [];\n    this.addCubes(raiseToLimit(initialize, 1));\n  }\n\n  raiseToLimit(num, limit) {\n    return num < limit ? limit : num;\n  }\n\n  addCubes(num) {\n    const { storage, geometry, material } = this;\n    for (let i = 0; i < num; i++) {\n      const mesh = new THREE.Mesh(geometry, material);\n      storage.push(mesh);\n    }\n  }\n\n  //public api\n  addCube(x, y, z) {\n    const { storage, cubesInScene, addCubes, scene } = this;\n    if (storage.length === 0) {\n      addCubes(cubesInScene.length);\n    }\n    const mesh = storage.pop();\n    mesh.position.set(x, y, z);\n    scene.add(mesh);\n    cubesInScene.push(mesh);\n  }\n\n  removeCubes(test) {\n    let { scene, cubesInScene, storage } = this;\n    const newCubesInScene = [];\n    cubesInScene.forEach(mesh => {\n      if (test(mesh)) {\n        scene.remove(mesh);\n        storage.push(mesh);\n      } else {\n        newCubesInScene.push(mesh);\n      }\n    });\n    cubesInScene = newCubesInScene;\n  }\n\n  reset() {\n    let { storage, cubesInScene, scene } = this;\n    cubesInScene.forEach(mesh => {\n      scene.remove(mesh);\n      storage.push(mesh);\n    });\n    cubesInScene = [];\n  }\n\n  length() {\n    return this.cubesInScene.length;\n  }\n\n  some(test) {\n    this.cubesInScene.some(test);\n  }\n\n}\n\nexport default CubeStore;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./cubeStore.js\n// module id = 0\n// module chunks = 0","import CubeStore from './cubeStore.js';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n\n  //initialize global game/view state vars\n  let gameOn = false;\n  const startGameSpeed = 7.5;\n  let gameSpeed = startGameSpeed;\n  let lastAddedCubesPos = gameSpeed * 50;\n  let paused = false;\n  let backgroundColor = [40, 44, 47];\n  let speedScore = 0;\n  let totalScore = 0;\n  let gameStarted = false;\n  let isLandscape = /.*landscape.*/.test(screen.orientation.type);\n  let lastOrient = undefined;\n  let fullScreen = false;\n\n  const newGameDisplay = Array.from(document.querySelectorAll(\".not-score\"));\n\n\n  const toggleFullscreen = () => {\n    if (fullScreen) {\n      exitFS();\n    } else {\n      reqFS();\n    }\n  };\n\n\n  window.onresize = function() {\n    if (fullScreen) {\n      resizeScreen(fullScreen, true);\n    }\n  };\n\n  const newGameButton = document.querySelector(\".new-game-text\");\n  const highScoreDisplay = document.getElementById(\"high-score\");\n  const canvas = document.getElementById(\"myCanvas\");\n  const fullscreenBtn = document.querySelector(\".btn.left\");\n  const body = document.querySelector(\"body\");\n\n  let exitFS = (document.exitFullscreen ||\n    document.webkitExitFullscreen ||\n    document.mozCancelFullScreen ||\n    document.msExitFullscreen).bind(document);\n\n  let reqFS = (body.requestFullscreen ||\n    body.webkitRequestFullscreen ||\n    body.mozRequestFullScreen ||\n    body.msRequestFullscreen).bind(body);\n\n  let isMobile = (/Android|webOS|iPhone|iPad|iPod|BlackBerry|BB|PlayBook|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent));\n\n  let fsBool = false;\n  const reqFSMobile = () => {\n    if (fsBool) reqFS();\n    document.removeEventListener('click', reqFSMobile);\n  };\n\n  if (isMobile) {\n    document.querySelector(\".desktop-instructions\").setAttribute(\"style\", \"display: none;\");\n    document.querySelector(\".mobile-instructions\").setAttribute(\"style\", \"display: block;\");\n    setTimeout(() => {\n      fsBool = confirm(\"Would you like to play in fullscreen? (click anywhere on the screen after)\");\n      if (fsBool) {\n\n        document.addEventListener('click', reqFSMobile);\n      }\n    }, 0);\n  }\n\n\n  fullscreenBtn.onclick = toggleFullscreen;\n\n\n  function resizeScreen(isDefault, wasRotated) {\n      if(isDefault) {\n        renderer.setSize(window.innerWidth / 1.2, window.innerHeight / 1.2);\n        camera.aspect = window.innerWidth / window.innerHeight;\n        camera.updateProjectionMatrix();\n      } else {\n        renderer.setSize(400, 300);\n        camera.aspect = 400 / 300;\n        camera.updateProjectionMatrix();\n      }\n  }\n\n  function fullScreenUpdate(e) {\n    fullScreen = !fullScreen;\n    setTimeout(() => resizeScreen(fullScreen), 0);\n  }\n\n  setHighScore();\n\n  newGameButton.onclick = () => newGame();\n\n\n  //setup three.js objects/variables\n\n  const renderer = new THREE.WebGLRenderer({canvas: canvas, antialias: true});\n  renderer.setClearColor(0x282c2f);\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.setSize(400, 300);\n\n  const camera = new THREE.PerspectiveCamera(35, 4/3, 0.1, 700);\n  const scene = new THREE.Scene();\n\n  const light = new THREE.AmbientLight(0xffffff, 0.5);\n  scene.add(light);\n  const light1 = new THREE.PointLight(0xffffff, 0.5);\n  scene.add(light1);\n\n  const geometry = new THREE.CubeGeometry(10, 10, 10);\n  const material = new THREE.MeshLambertMaterial({color: 0xF3FFE2});\n\n  const store = new CubeStore(scene, geometry, material, 1000);\n\n  var planeGeometry = new THREE.PlaneGeometry( 1000, 4000);\n  var planeMaterial = new THREE.MeshBasicMaterial( {color: 0xBBBBBB, side: THREE.DoubleSide} );\n  var plane = new THREE.Mesh( planeGeometry, planeMaterial );\n  plane.position.z = -10;\n  plane.position.y = -3;\n  plane.rotation.x = -Math.PI/2;\n\n  scene.add( plane );\n\n  THREE.TetrahedronGeometry = function ( radius, detail ) {\n\n      var vertices = [ 0,  0,  0,   0, 1,  0,   1,  0, 0,    0, 0, 1];\n      var indices = [ 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1];\n\n      THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n  };\n\n  THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n  const playerSize = 7;\n\n  const playerGeometry = new THREE.TetrahedronGeometry(playerSize, 0);\n\n\n  playerGeometry.vertices[0].y = playerSize / 2;\n  playerGeometry.vertices[2].x = playerSize / 2;\n\n\n  const playerMaterial = new THREE.MeshStandardMaterial({color: 0xF3FFE2});\n  const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);\n  playerMesh.position.z = -50;\n  playerMesh.rotation.x = -0.4;\n  playerMesh.rotation.z = -2.355;\n\n  camera.position.y = 15;\n  camera.rotation.x = -0.1;\n\n  const keyState = { keydown: false, right: false, left: false, xAccel: 0, xSpeed: 0, maxXSpeed: 2.5, up: false };\n\n  function newGame() {\n    newGameDisplay.forEach(el => el.setAttribute(\"style\", \"display: none;\"));\n    scene.children[3] = playerMesh;\n    keyState.keydown = false;\n    keyState.right = false;\n    keyState.left = false;\n    keyState.xAccel = 0;\n    keyState.xSpeed = 0;\n    keyState.maxXSpeed = 2.5;\n    camera.position.z = 0;\n    camera.position.x = 0;\n    playerMesh.position.z = -50;\n    plane.position.z = -10;\n    plane.position.y = -3;\n    gameOn = true;\n    gameSpeed = 6;\n    paused = false;\n    lastAddedCubesPos = gameSpeed * 50;\n    scene.children.slice(4).forEach(child => scene.remove(child));\n    store.reset();\n    backgroundColor = [40, 44, 47];\n    speedScore = 0;\n    totalScore = 0;\n    gameStarted = true;\n    const currOrientation = screen.orientation.type;\n    screen.orientation.lock(currOrientation);\n    // const locOrientation = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation || screen.orientation.lock;\n    // screen.locOrientation(currOrientation);\n  }\n\n  requestAnimationFrame(render);\n\n  function render() {\n    if (!gameStarted || (gameOn && !paused)) {\n      update(camera, scene, keyState, playerMesh);\n    }\n      renderer.render(scene, camera);\n      requestAnimationFrame(render);\n  }\n\n  function canPlaceCube(pos1, pos2, size = 10) {\n    return !(Math.abs(pos1.x - pos2.x) < size && Math.abs(pos1.z - pos2.z) < size);\n  }\n\n  function addCubes(scene, camera, size = 10) {\n    const numCubes = Math.floor(Math.random() * 10) + 75;\n    const newPoses = [];\n    for (let i = 0; i < numCubes; i++) {\n      let valid = false,\n          newPos = {};\n      while (!valid) {\n        const x = Math.floor(Math.random() * 2000) - 1000 + camera.position.x;\n        const z = Math.floor(Math.random() * 480) - 1490 + camera.position.z;\n        newPos = { x, z };\n        valid = !newPoses.some(pos => !canPlaceCube(pos, newPos, size));\n      }\n      newPoses.push(newPos);\n    }\n    const pos_y = 3;\n    newPoses.forEach(pos => store.addCube(pos.x, pos_y, pos.z));\n  }\n\n  function removeCubes(camera) {\n    if (store.length > 1000) {\n      store.removeCubes(cube => cube.position.z > camera.position.z);\n    }\n  }\n\n  function reduceToLimit(num, limit, lowerLimit) {\n    if (!lowerLimit && Math.abs(num) > limit) {\n      return num < 0 ? -limit : limit;\n    } else if (lowerLimit && Math.abs(num) < limit) {\n      return limit;\n    } else {\n      return num;\n    }\n  }\n\n  function handleGameSpeed(camera) {\n    const lvlDistanceConst = 15000;\n    [1,2,3,4,5].forEach(num => {\n      if (totalScore > num * lvlDistanceConst && gameOn) {\n        gameSpeed = startGameSpeed + 1 * num;\n      }\n    });\n  }\n\n  function updateCameraPos(camera, keyState, playerMesh) {\n    if (keyState.up) {\n      camera.position.z -= gameSpeed + 3;\n    }\n    if (!isMobile) {\n      updateSpeed(keyState);\n    }\n    camera.position.x += keyState.xSpeed;\n    camera.rotation.z = -0.2 * ( keyState.xSpeed / keyState.maxXSpeed );\n    camera.position.z -= gameSpeed;\n    playerMesh.position.x = camera.position.x;\n    playerMesh.rotation.z = camera.rotation.z - 2.35;\n    playerMesh.position.z = camera.position.z - 50;\n    plane.position.z = camera.position.z -2000;\n    plane.position.x = camera.position.x;\n  }\n\n  function updateSpeed(keyState) {\n    const turnSpd = 0.25;\n    if (keyState.keydown && !(keyState.left && keyState.right)) {\n      if (keyState.right) {\n        keyState.xAccel = turnSpd;\n      } else {\n        keyState.xAccel = -turnSpd;\n      }\n    } else {\n      if (keyState.xSpeed !== 0) {\n        if (Math.abs(keyState.xSpeed) < 0.1) {\n          keyState.xSpeed = 0;\n          keyState.xAccel = 0;\n        } else if (Math.abs(keyState.xSpeed) < 1) {\n          keyState.xAccel = keyState.xSpeed < 0 ? 0.03 : -0.03;\n        } else {\n          keyState.xAccel = keyState.xSpeed < 0 ? 0.2 : -0.2;\n        }\n      }\n    }\n    keyState.xSpeed = reduceToLimit(keyState.xSpeed + keyState.xAccel, keyState.maxXSpeed);\n  }\n\n\n  function doSomethingIfGameIsOver(playerMesh, size) {\n    const gameOver = store.some(cube => (\n      cube.position.x - size/2 < playerMesh.position.x &&\n      cube.position.x + size/2 > playerMesh.position.x &&\n      cube.position.z - size/2 < playerMesh.position.z + 7 &&\n      cube.position.z + size/2 > playerMesh.position.z - 7\n    ));\n    return gameOver;\n  }\n\n  function updateScore(camera) {\n    if (keyState.up && gameOn) {\n      speedBonus = Math.floor((backgroundColor[0] - 40) / 10);\n      const hasMaxBonus = backgroundColor[0] === 255;\n      speedScore += hasMaxBonus ? 30 : speedBonus;\n    }\n    const roundedScore = -Math.floor(camera.position.z);\n    if (gameOn) {\n      totalScore = speedScore + roundedScore;\n      document.getElementById(\"score\").innerHTML = totalScore;\n      document.getElementById(\"score2\").innerHTML = totalScore;\n    }\n  }\n\n  function updateScreenColor(keyState) {\n    if (keyState.up) {\n      backgroundColor[0] = reduceToLimit(backgroundColor[0] + 1, 255);\n      backgroundColor[1] = reduceToLimit(backgroundColor[1] + 1, 255);\n      backgroundColor[2] = reduceToLimit(backgroundColor[2] + 1, 255);\n    } else {\n      backgroundColor[0] = reduceToLimit(backgroundColor[0] - 3, 40, 'lowerLimit');\n      backgroundColor[1] = reduceToLimit(backgroundColor[1] - 3, 44, 'lowerLimit');\n      backgroundColor[2] = reduceToLimit(backgroundColor[2] - 3, 47, 'lowerLimit');\n    }\n    const [r, g, b] = backgroundColor;\n    document.querySelector(\"body\").setAttribute(\"style\", `background: rgb(${r}, ${g}, ${b});`);\n  }\n\n  function setHighScore() {\n    let oldScore = Number(localStorage.getItem(\"highscore\"));\n    let newScore = oldScore && oldScore > totalScore ? oldScore : totalScore;\n    localStorage.setItem(\"highscore\", newScore);\n    highScoreDisplay.innerHTML = newScore;\n  }\n\n  function handleGameOver(scene) {\n    gameOn = false;\n    gameSpeed = startGameSpeed - 3;\n    keyState.up = false;\n    keyState.xSpeed = 0;\n    setHighScore();\n    scene.remove(playerMesh);\n    gameStarted = false;\n    newGameDisplay.forEach(el => el.setAttribute(\"style\", \"display: default;\"));\n    if (isMobile) {\n      document.querySelector(\".desktop-instructions\").setAttribute(\"style\", \"display: none;\");\n      document.querySelector(\".mobile-instructions\").setAttribute(\"style\", \"display: block;\");\n    }\n  }\n\n  function update(camera, scene, keyState, playerMesh) {\n    const cubeSize = 10;\n    updateCameraPos(camera, keyState, playerMesh);\n    handleGameSpeed(camera);\n    updateScreenColor(keyState);\n    updateScore(camera);\n    if ((lastAddedCubesPos - camera.position.z) >= 6 * 50) {\n      addCubes(camera, cubeSize);\n      lastAddedCubesPos = camera.position.z;\n    }\n    removeCubes(camera);\n    if (doSomethingIfGameIsOver(playerMesh, cubeSize)) {\n      handleGameOver(scene);\n    }\n  }\n\n  function orientationUpdate(e) {\n    if (lastOrient !== undefined && lastOrient !== window.orientation) {\n      resizeScreen(fullScreen, true);\n      isLandscape = Math.abs(window.orientation) === 90;\n      lastOrient = window.orientation;\n    } else if (lastOrient === undefined) {\n      lastOrient = window.orientation;\n    }\n\n    let orient;\n    if (isLandscape) {\n      orient = e.beta;\n    } else {\n      orient = e.gamma;\n    }\n    if (orient > 30)\n    orient = 30;\n    if (orient < -30)\n    orient = -30;\n    orient = orient / 10;\n    if (gameOn) {\n      const landscapePrimary = (/.*primary.*/).test(screen.orientation.type);\n      keyState.xSpeed = (isLandscape && !landscapePrimary ? -1 : 1) * orient;\n    }\n  }\n\n\n  document.addEventListener('keydown', (e) => {\n    if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {\n      e.preventDefault();\n    }\n    switch(e.key) {\n      case 'ArrowLeft': {\n        keyState.keydown = true && gameOn;\n        keyState.left = true && gameOn;\n        break;\n      }\n      case 'ArrowRight': {\n        keyState.keydown = true && gameOn;\n        keyState.right = true && gameOn;\n        break;\n      }\n      case 'ArrowUp': {\n        keyState.up = true && gameOn;\n        break;\n      }\n      case 'r': {\n        newGame();\n        break;\n      }\n      case 'p': {\n        paused = gameOn ? !paused : false;\n        break;\n      }\n    }\n  });\n\n  document.addEventListener('keyup', (e) => {\n    switch(e.key) {\n      case 'ArrowLeft': {\n        keyState.left = false;\n        break;\n      }\n      case 'ArrowRight': {\n        keyState.right = false;\n        break;\n      }\n      case 'ArrowUp': {\n        keyState.up = false;\n        break;\n      }\n    }\n    if (!keyState.right && !keyState.left) {\n      keyState.keydown = false;\n    }\n  });\n\n  document.addEventListener('touchstart', (e) => {\n    if (gameOn) {\n      keyState.up = true;\n    }\n  });\n\n  document.addEventListener('touchend', (e) => {\n    keyState.up = false;\n  });\n\n  window.addEventListener(\"deviceorientation\", (e) => isMobile && orientationUpdate(e), false);\n\n  document.addEventListener(\"fullscreenchange\", fullScreenUpdate, false);\n\n  document.addEventListener(\"mozfullscreenchange\", fullScreenUpdate, false);\n\n  document.addEventListener(\"webkitfullscreenchange\", fullScreenUpdate, false);\n\n  document.addEventListener(\"msfullscreenchange\", fullScreenUpdate, false);\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./DodgeDodge.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}