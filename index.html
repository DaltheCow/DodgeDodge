<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Dodge Dodge</title>
  </head>
  <body>
    <canvas id="myCanvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js" charset="utf-8"></script>
    <script type="text/javascript">

      const addCube = (x, y, z, scene, size = 10) => {
        const geometry = new THREE.CubeGeometry(size, size, size);
        const material = new THREE.MeshLambertMaterial({color: 0xF3FFE2});
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, y, z);
        scene.add(mesh);
        return mesh;
      }

      const canPlaceCube = (pos1, pos2, size = 10) => {
        return !(Math.abs(pos1.x - pos2.x) < size && Math.abs(pos1.z - pos2.z) < size)
      }

      const addCubes = (scene, camera, size = 10) => {
        const numCubes = Math.floor(Math.random() * 10) + 40
        const newPoses = [];
        for (let i = 0; i < numCubes; i++) {
          let valid = false,
              newPos = {};
          while (!valid) {
            const x = Math.floor(Math.random() * 2000) - 1000 + camera.position.x;
            const z = Math.floor(Math.random() * 480) - 1490 + camera.position.z;
            newPos = { x, z };
            valid = !newPoses.some(pos => !canPlaceCube(pos, newPos, 10));
          }
          newPoses.push(newPos)
        }
        return newPoses.map(pos => addCube(pos.x, 0, pos.z, scene, size));
      }

      const removeCubesBang = (cubeArray, scene) => {
        if (cubeArray.length > 500) {
          for (let i = 0; i < cubeArray.length - 400; i++) {
            scene.remove(cubeArray[i])
          }
          cubeArray.splice(0, cubeArray.length - 400)
        }
      }

      const reduceToLimit = (num, limit) => {
        if (Math.abs(num) > limit) {
          return num < 0 ? -limit : limit
        } else {
          return num
        }
      }

      const updateCameraPos = (camera, keyState) => {
        if (keyState.keydown && !(keyState.left && keyState.right)) {
          if (keyState.right) {
            keyState.xAccel = .7;
          } else {
            keyState.xAccel = -.7;
          }

        } else {
          if (keyState.xSpeed !== 0) {
            if (Math.abs(keyState.xSpeed) < .1) {
              keyState.xSpeed = 0;
              keyState.xAccel = 0;
            } else if (Math.abs(keyState.xSpeed) < 1) {
              keyState.xAccel = keyState.xSpeed < 0 ? .01 : -.01;
            } else {
              keyState.xAccel = keyState.xSpeed < 0 ? .2 : -.2;
            }
          }
        }
        keyState.xSpeed = reduceToLimit(keyState.xSpeed + keyState.xAccel, keyState.maxXSpeed);
        camera.position.x += keyState.xSpeed;
        camera.rotation.z = -.2 * ( keyState.xSpeed / keyState.maxXSpeed )
        camera.position.z -= 10;
      }

      const doSomethingIfGameIsOver = (cubeArray, camera) => {
        const gameOver = cubeArray.some(cube => cube.position.x)
      }

      const update = (cubeArray, camera, scene, keyState) => {
        updateCameraPos(camera, keyState)
        if (camera.position.z % 500 === 0) {
          cubeArray = cubeArray.concat(addCubes(scene, camera, 10));
        }
        removeCubesBang(cubeArray, scene)
        doSomethingIfGameIsOver();

        return cubeArray
      }

      (function(){
        let cubeArray = []
        const renderer = new THREE.WebGLRenderer({canvas: document.getElementById("myCanvas"), antialias: true});
        renderer.setClearColor(0xCCCCCC);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1200);
        const scene = new THREE.Scene();

        const light = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(light);
        const light1 = new THREE.PointLight(0xffffff, 0.5);
        scene.add(light1);

        requestAnimationFrame(render);

        const keyState = { keydown: false, right: false, left: false, xAccel: 0, xSpeed: 0, maxXSpeed: 7 }

        function render() {
          cubeArray = update(cubeArray, camera, scene, keyState)
          renderer.render(scene, camera);
          requestAnimationFrame(render);
        }


        document.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            e.preventDefault();
          }
          switch(e.key) {
            case 'ArrowLeft': {
              keyState.keydown = true;
              keyState.left = true
              break;
            }
            case 'ArrowRight': {
              keyState.keydown = true;
              keyState.right = true
              break;
            }
          }

        })

        document.addEventListener('keyup', (e) => {
          switch(e.key) {
            case 'ArrowLeft': {
              keyState.left = false;
              break;
            }
            case 'ArrowRight': {
              keyState.right = false;
              break;
            }
          }
          if (!keyState.right && !keyState.left) {
            keyState.keydown = false;
          }

        })

      })();


    </script>
  </body>
</html>
